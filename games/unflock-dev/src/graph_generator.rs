// SPDX-License-Identifier: MIT
// UnFlock Authors: see AUTHORS.txt

use itertools::Itertools;
use std::ops::RangeInclusive;

use bevy::math::Vec2;
use bevy::math::Vec3;

use crate::consts::MINIMUM_GRAPH_COMPLEXITY;
use crate::math::*;

/*
Planar Graph Generation Algorithm by John Tantalo
(http://johntantalo.com/wiki/Planarity/)

    1. Generate a set of random lines in a plane such that no two lines are parallel.
    2. Calculate the intersections of every line pair.
    3. Create a graph with a vertex for each intersection and an edge for each line segment connecting two intersections.

If a graph is generated from n lines, then the graph will have n choose 2 = n(n-1)/2 vertices (each line has n-1 vertices, each vertex is shared with one other line) and n(n-2) edges (each line contains n-2 edges).

The first level of Planarity is built from n=4 lines, so it has n(n-1)/2=6 vertices and n(n-2)=8 edges. Each level after is generated by one more line than the last. If a level was generated with n lines, then the next level has n more vertices and 2n-1 more edges.

The algorithm assumes lists index from 1.

Input: a list L of n 2-dimensional lines, and a labeling A from each p in L to {1...n}

Pseudocode

Let G be an empty graph.

Add vertices {1...n(n-1)/2} to G.

For each line p in L:
    Let M be the lines q in L ordered by the intersection points of p with q and p != q.

    For each consecutive pair Mi and Mi+1:
        Let u = PairIndex(A(p), A(Mi), n).
        Let v = PairIndex(A(p), A(Mi+1), n).
        Add an edge (u, v) to G.

Return G.
 */
pub fn generate_graph(n: u32) -> Graph {
    assert!(n >= MINIMUM_GRAPH_COMPLEXITY);

    let mut graph = Graph::new();
    // intialize vertices
    let vertex_count = n * (n - 1) / 2;
    (0..vertex_count).for_each(|_| graph.add_vertex());

    let lines = generate_intersecting_lines(n as usize);

    for current_index in 0..lines.len() {
        let (current_line, current_line_index) = &lines[current_index];
        // all lines except current_line
        let mut all_but_current_line: Vec<&(LineSegment, u32)> = lines
            .iter()
            .filter(|(line, _index)| current_line != line)
            .collect();
        // sort by intersections
        all_but_current_line.sort_by(|(line_a, _index_a), (line_b, _index_b)| {
            let intersection_a = current_line
                .intersect_lines(line_a)
                .expect("missing intersection");
            let intersection_b = current_line
                .intersect_lines(line_b)
                .expect("missing intersection");
            // if intersection_b has a higher x value,
            // the difference is negative
            // => line_a gets placed before line_b
            intersection_b.x.partial_cmp(&intersection_a.x).unwrap()
        });

        // create edges
        all_but_current_line
            .iter()
            // convert object vector to index vector
            .map(|(_line, index)| *index as i32)
            // sliding window over the iterator
            .tuple_windows()
            // always map the current and next index
            // to their respective pair indices
            .map(|(edge_index, edge_index_next)| {
                let u = pair_index(*current_line_index as i32, edge_index, n as i32)
                    .expect("pair_index input is broken");
                let v = pair_index(*current_line_index as i32, edge_index_next, n as i32)
                    .expect("pair_index input is broken");
                (u, v)
            })
            // crate a graph edge for each pair_index pair
            .for_each(|(u, v)| {
                graph.add_edge(u as u32, v as u32);
            });
    }

    graph
}

/// randomly generate n lines, where no two lines are parallel
fn generate_intersecting_lines(n: usize) -> Vec<(LineSegment, u32)> {
    // indices must start with 1
    let mut lines = vec![(LineSegment::random(), 1)];
    // generate n intersecting lines
    while lines.len() != n {
        let new_line = LineSegment::random();

        // collect all lines that do not intersect
        let parallel_lines_count = lines
            .iter()
            .filter(|(line, _index)| line.intersect_lines(&new_line).is_none())
            .count();

        // no parallel lines allowed
        if parallel_lines_count > 0 {
            continue;
        }

        lines.push((new_line, (lines.len() + 1) as u32));
    }
    lines
}

///
/// PairIndex (http://johntantalo.com/wiki/Planarity/)
///
/// In the graph, every pair of distinct lines (p, q) corresponds to exactly one vertex v,
/// but it is much more convenient to address this vertex as a single value than a tuple.
/// So, how do we most efficiently map (p, q) into v?
/// The function PairIndex does this by mapping each (p, q)
/// to some number between 1 and (n(n-1)/2) (inclusive), the range of vertices.
///
/// Definition
///
/// If 1 <= p < q <= n, then PairIndex(p, q) = (p-1)(2n-p)/2+q-p
///
/// Claim
///
/// PairIndex is a bijection (i.e., one-to-one and onto) between
/// {(p, q) | 1 <= p < q <= n} and {1...n(n-1)/2} for a fixed n.
///
/// Proof
///
/// Observe that PairIndex is linear in q when p is fixed.
/// When p=1, PairIndex takes on the values {1..n-1}.
/// When p=n-1, PairIndex is n(n-1)/2.
/// For a given p, the the minimum value is PairIndex(p,n) and the maximum value is PairIndex(p,p+1).
/// Basic algebraic manipulation is required to show that the maximum value of PairIndex for any p
/// is exactly one less than the minimum value for p+1.
/// Therefore every value in {1...n(n-1)/2} must correspond to exactly one pair (p, q).
/// q.e.d.
///
/// This proof is due to Mary Radcliffe.
///
fn pair_index(p: i32, q: i32, n: i32) -> Result<i32, ()> {
    // p must be smaller than q for pair_index to be bijective
    if p >= q {
        return pair_index(q, p, n);
    }
    if 1 <= p && q <= n {
        Ok(((p - 1) * (2 * n - p) / 2) + q - p)
    } else {
        Err(())
    }
}

///
pub struct Graph {
    vertex_count: u32,
    edges: Vec<Edge>,
}

impl Graph {
    ///
    pub fn new() -> Self {
        Self {
            vertex_count: 0,
            edges: vec![],
        }
    }

    ///
    pub fn vertices(&self) -> RangeInclusive<u32> {
        1..=self.vertex_count
    }

    ///
    pub fn edges(&self) -> Vec<Edge> {
        self.edges.clone()
    }

    ///
    fn add_vertex(&mut self) {
        // add +1, since algorithm ...
        self.vertex_count += 1;
    }

    ///
    fn add_edge(&mut self, from: u32, to: u32) {
        self.edges.push(Edge(from, to));
    }
}

///
#[derive(Copy, Clone, Debug)]
pub struct Edge(pub u32, pub u32);

// Basic types needed for graph generation

type BaseType = i32;

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub struct Intersect {
    pub x: BaseType,
    pub y: BaseType,
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub struct Vec2i {
    pub x: BaseType,
    pub y: BaseType,
}

impl Vec2i {
    pub fn random() -> Self {
        Self {
            x: rand(),
            y: rand(),
        }
    }
}

impl From<Vec3> for Vec2i {
    fn from(vec: Vec3) -> Self {
        Self {
            x: vec.x.round() as BaseType,
            y: vec.y.round() as BaseType,
        }
    }
}
impl From<&Vec3> for Vec2i {
    fn from(vec: &Vec3) -> Self {
        Self {
            x: vec.x.round() as BaseType,
            y: vec.y.round() as BaseType,
        }
    }
}

impl From<Vec2> for Vec2i {
    fn from(vec: Vec2) -> Self {
        Self {
            x: vec.x.round() as BaseType,
            y: vec.y.round() as BaseType,
        }
    }
}
impl From<&Vec2> for Vec2i {
    fn from(vec: &Vec2) -> Self {
        Self {
            x: vec.x.round() as BaseType,
            y: vec.y.round() as BaseType,
        }
    }
}

impl From<&Intersect> for Vec2i {
    fn from(vec: &Intersect) -> Self {
        Self { x: vec.x, y: vec.y }
    }
}

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum SegmentIntersectionType {
    None,
    CoLinear,
    Some(Intersect),
}

impl SegmentIntersectionType {
    #[allow(dead_code)]
    pub fn is_none(&self) -> bool {
        match self {
            Self::Some(_) => false,
            _ => true,
        }
    }
    #[allow(dead_code)]
    pub fn is_some(&self) -> bool {
        return !self.is_none();
    }
    #[allow(dead_code)]
    pub fn is_colinear(&self) -> bool {
        match self {
            Self::CoLinear => true,
            _ => false,
        }
    }
    #[allow(dead_code)]
    pub fn unwrap(&self) -> Intersect {
        match self {
            Self::Some(i) => i.clone(),
            _ => panic!("IntersectionType is not Some(_)"),
        }
    }
    #[allow(dead_code)]
    pub fn expect(&self, msg: String) -> Intersect {
        match self {
            Self::Some(i) => i.clone(),
            _ => panic!("{}", msg),
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub struct LineSegment {
    start: Vec2i,
    end: Vec2i,
    a_x: i32,
    b_y: i32,
    c: i32,
}

impl From<(&Vec3, &Vec3)> for LineSegment {
    fn from(line_points: (&Vec3, &Vec3)) -> Self {
        let from: Vec2i = line_points.0.into();
        let to: Vec2i = line_points.1.into();
        Self::from((&from, &to))
    }
}

impl From<(&Vec2i, &Vec2i)> for LineSegment {
    fn from(line_points: (&Vec2i, &Vec2i)) -> Self {
        Self {
            start: *line_points.0,
            end: *line_points.1,
            a_x: line_points.1.y - line_points.0.y, // to.y - from.y
            b_y: line_points.0.x - line_points.1.x, // from.x - to.x
            c: line_points.1.x * line_points.0.y - line_points.0.x * line_points.1.y, // to.x * from.y - from.x * to.y
        }
    }
}

impl LineSegment {
    /// create a line with randomly initialized constants
    pub fn random() -> Self {
        let from = Vec2i::random();
        let to = Vec2i::random();
        Self::from((&from, &to))
    }

    pub fn a_x(&self) -> BaseType {
        self.a_x
    }
    pub fn b_y(&self) -> BaseType {
        self.b_y
    }
    pub fn c(&self) -> BaseType {
        self.c
    }

    #[allow(dead_code)]
    pub fn start(&self) -> &Vec2i {
        &self.start
    }

    #[allow(dead_code)]
    pub fn end(&self) -> &Vec2i {
        &self.end
    }

    pub fn distance_of(&self, other: &Vec2i) -> BaseType {
        self.a_x * other.x + self.b_y * other.y + self.c
    }

    ///
    /// https://webdocs.cs.ualberta.ca/~graphics/books/GraphicsGems/gemsii/xlines.c
    /// alternative? https://github.com/nical/lyon/commit/68559e32e5cde168c7c7d2494693efbc66b3cf3b
    pub fn intersect_segments(&self, other: &Self) -> SegmentIntersectionType {
        // If distance is 0, then the point is on self.
        // If distance signs from both other.from and other.to are the same,
        // then they are on the same (upper or lower) half-plane described
        // by self.
        let dist_other_from = self.distance_of(&other.start);
        let dist_other_to = self.distance_of(&other.end);
        if (dist_other_from != 0 && dist_other_to != 0) && dist_other_from.same_sign(dist_other_to)
        {
            return SegmentIntersectionType::None;
        }

        // If distance is 0, then the point is on other.
        // If distance signs from both self.from and self.to are the same,
        // then they are on the same (upper or lower) half-plane described
        // by other.
        let dist_self_from = other.distance_of(&self.start);
        let dist_self_to = other.distance_of(&self.end);
        if dist_self_from != 0 && dist_self_to != 0 && dist_self_from.same_sign(dist_self_to) {
            return SegmentIntersectionType::None;
        }

        // check colinearity
        let determinant = self.a_x() * other.b_y() - self.b_y() * other.a_x();
        if 0 == determinant {
            // lines are colinear
            return SegmentIntersectionType::CoLinear;
        }

        // prevent intersections from edges ending in same vertex
        if self.start == other.start
            || self.start == other.end
            || self.end == other.start
            || self.end == other.end
        {
            return SegmentIntersectionType::None;
        }

        // calculate intersection
        SegmentIntersectionType::Some(Intersect {
            x: (self.b_y() * other.c() - other.b_y() * self.c()) / determinant,
            y: (other.a_x() * self.c() - self.a_x() * other.c()) / determinant,
        })
    }

    ///
    pub fn intersect_lines(&self, other: &Self) -> Option<Intersect> {
        let determinant = self.a_x() * other.b_y() - self.b_y() * other.a_x();
        if 0 == determinant {
            // lines are parallel
            return None;
        }

        // calculate intersection
        Some(Intersect {
            x: (self.b_y() * other.c() - other.b_y() * self.c()) / determinant,
            y: (other.a_x() * self.c() - self.a_x() * other.c()) / determinant,
        })
    }
}
